# -*- coding: utf-8 -*-

__all__ = [
    'CatrisksBaseKeysLookup'
]

import csv
import io
import logging
import os
import math
import pandas as pd
import sys

from oasislmf.model_preparation.lookup import (
    OasisBaseKeysLookup,
    UNKNOWN_ID,
)
from oasislmf.utils.coverages import (
    COVT_BLD,
    COVT_CON,
    COVT_BIT,
)
from oasislmf.utils.read_csv import read_csv
#from read_csv import read_csv
from oasislmf.utils.log import oasis_log
from oasislmf.utils.peril import PRL_WSS
from oasislmf.utils.status import OASIS_KEYS_FL

import keys_server.utils as common_utils



class CatrisksBaseKeysLookup(OasisBaseKeysLookup):
    """
    CatRisks base model keys lookup.
    """

    @oasis_log()
    def __init__(self, keys_data_directory=None, supplier='Catrisks', model_name=None, model_version=None):
        """
        Initialise the static data required for the lookup.
        """
        super(CatrisksBaseKeysLookup, self).__init__(
            keys_data_directory,
            supplier,
            model_name,
            model_version
        )

        (
            self.areas,
            self.lonlat_origin,
            self.vrg_areas_grid,
            self.vrg_areas_grid_corners,
        ) = self._read_areas(os.path.join(self.keys_data_directory, 'DictAreaPeril.csv'))

        self.vulnerabilities = self._read_vulnerabilities(os.path.join(self.keys_data_directory, 'DictVULNERABILITY.csv'))
        self.location_map = self._read_location_mappings(self.keys_data_directory)

        self.vulnerability_map = self._read_vulnerability_mappings(self.keys_data_directory)
        self.construction_class = self._read_construction_classes(self.keys_data_directory)


    @oasis_log()
    def process_locations(self, loc_df):
        """
        Process location rows - passed in as a pandas dataframe.
        """
#        r1, r2 = [], []
        r1 = []
        for i in range(len(loc_df)):
            loc_row = loc_df.iloc[i]
            record = self._get_location_record(loc_row)
            record['model_name'] = self.model_name
            row_failed = False

            ap_id = vul_id = UNKNOWN_ID
            area_peril_message = vulnerability_message = ''
            coverage_type = ''

            for row in self.location_map['AREA_LEVEL_1']:
                if record['country'].upper() == row['area_level_names'].upper():
                    record['country'] = row['area_level_model_names'].upper()
                    break
            try:

                if common_utils.no_latlon(record):
                   record['gridxy'] = None
                else:
                    record['gridxy'] = common_utils.get_area_peril_grid_coordinates_for_location(
                        record['longitude'],
                        record['latitude'],
                        origin=self.lonlat_origin
                    )

                common_utils.fix_locations_by_dictionary(record, self.location_map)
                ap_id, area_peril_message, mapping_type = self._get_area_peril_id(record)

                #coverage_type = BUILDING_COVERAGE_CODE
                coverage_type = COVT_BLD
                record['coverage_type'] = common_utils.CATRISKS_BUILDING_COVERAGE_CODE
                vul_id_1, vulnerability_message = self._get_vulnerability_id(record)
                #logging.exception("record: {}".format(str(record)))
            except Exception as e:
                row_failed = True
                logging.exception("Error {} processing location: {}".format(str(e), loc_row.to_json()))

            #status = KEYS_STATUS_FAIL if row_failed else self._get_lookup_success(ap_id, vul_id_1)
            status = OASIS_KEYS_FL if row_failed else self._get_custom_lookup_success(ap_id, vul_id_1)
            #logging.exception("ap_id: {}, vul_id: {}".format(str(ap_id), str(vul_id_1)))
            r1.append({
                "loc_id": record['loc_id'],
                "peril_id": PRL_WSS, #PERIL_ID_QUAKE,
                "coverage": coverage_type,
                "coverage_type": coverage_type,
                "area_peril_id": ap_id,
                "vulnerability_id": vul_id_1,
                "message": "{} - {}".format(area_peril_message, vulnerability_message),
                "status": status,
                "mapped_level":mapping_type
            })

            row_failed = False

            try:
                #coverage_type = CONTENTS_COVERAGE_CODE
                coverage_type = COVT_CON
                record['coverage_type'] = common_utils.CATRISKS_CONTENTS_COVERAGE_CODE
                vul_id_2, vulnerability_message = self._get_vulnerability_id(record)
            except Exception as e:
                row_failed = True
                logging.exception("Error {} processing location: {}".format(str(e), loc_row.to_json()))

            #status = KEYS_STATUS_FAIL if row_failed else self._get_lookup_success(ap_id, vul_id_2)
            status = OASIS_KEYS_FL if row_failed else self._get_custom_lookup_success(ap_id, vul_id_2)
            #logging.exception("ap_id: {}, vul_id: {}".format(str(ap_id), str(vul_id_2)))

            r1.append({
                "loc_id": record['loc_id'],
                "peril_id": PRL_WSS, #PERIL_ID_QUAKE,
                "coverage": coverage_type,
                "coverage_type": coverage_type,
                "area_peril_id": ap_id,
                "vulnerability_id": vul_id_2,
                "message": "{} - {}".format(area_peril_message, vulnerability_message),
                "status": status,
                "mapped_level": mapping_type
            })
            try:
                #coverage_type = TIME_COVERAGE_CODE
                coverage_type = COVT_BIT
                record['coverage_type'] = common_utils.CATRISKS_TIME_BUILDING_CODE
                vul_id_3, vulnerability_message = self._get_vulnerability_id(record)
            except Exception as e:
                row_failed = True
                logging.exception("Error {} processing location: {}".format(str(e), loc_row.to_json()))

            #status = KEYS_STATUS_FAIL if row_failed else self._get_lookup_success(ap_id, vul_id_3)
            status = OASIS_KEYS_FL if row_failed else self._get_custom_lookup_success(ap_id, vul_id_3)

            r1.append({
                "loc_id": record['loc_id'],
                "peril_id": PRL_WSS, #PERIL_ID_QUAKE,
                "coverage": coverage_type,
                "coverage_type": coverage_type,
                "area_peril_id": ap_id,
                "vulnerability_id": vul_id_3,
                "message": "{} - {}".format(area_peril_message, vulnerability_message),
                "status": status,
                "mapped_level": mapping_type
            })

#            disagg = common_utils.get_disaggregation(record, self.areas, mapping_type,ap_id)
#
#            for row in disagg:
#                r2.append({
#                    "location_id": record['loc_id'],
#                    "coverage_type": coverage_type,
#                    "area_peril_id": row ['area_id'],
#                    "cell_weigth": row ['weight'],
#                    "vulnerability_id": vul_id_2,
#                    "status": status
#                })
#        logging.exception("Success Records: {}".format(str(r1)))
#        logging.exception("Failure Records: {}".format(str(r2)))

        return r1 #, r2

    def _get_location_record(self, loc_item):
        """
        Construct a location record (dict) from the location item, which in this
        case is a row in a Pandas dataframe.
        """
        #meta = common_utils._LOCATION_RECORD_META if self.model_name != 'AFEQ' else common_utils._AFEQ_LOCATION_RECORD_META
        meta = common_utils._LOCATION_RECORD_META 
        return dict(
            (
                k,
                meta[k]['validator'](loc_item[meta[k]['csv_header'].lower()])
                #meta[k]['validator'](loc_item[meta[k]['csv_header']])
            ) for k in meta
        )


    def _get_area_peril_id(self, record):
        """
        Get the area peril ID for a particular location record.
        """
        return common_utils.get_area_peril_id(record, self.areas, self.vrg_areas_grid, self.vrg_areas_grid_corners)


    def _get_vulnerability_id(self, record):
        """
        Get the vulnerability ID for a particular location record.
        """
        return common_utils.get_vulnerability_id(
            record,
            self.vulnerabilities,
            self.vulnerability_map,
            self.construction_class
        )


    @oasis_log()
    def _read_areas(self, areas_file):
        #print('areas_file: {}'.format(areas_file))
        areas = [
            area for area in read_csv(
                areas_file,
                csv_meta=common_utils._AREA_RECORD_META
            )
        ]
        print(sys.getsizeof(common_utils.get_vrg_areas(areas)))
        lonlat_origin = common_utils.get_vrg_areas_lonlat_extrema(common_utils.get_vrg_areas(areas))[:2]
        vrg_areas_grid, vrg_areas_grid_corners = common_utils.get_vrg_area_peril_grid(areas)
        return areas, lonlat_origin, vrg_areas_grid, vrg_areas_grid_corners

    @oasis_log()
    def _read_vulnerabilities(self, vulnerabilities_file):
        return [
            vulnerability for vulnerability in read_csv(
                vulnerabilities_file,
                csv_meta=common_utils._VULNERABILITY_RECORD_META
            )
        ]

    @oasis_log()
    def _read_location_mappings(self, data_directory):
        area_level_location_mappings = {}
        for area_level_key in ["AREA_LEVEL_{}".format(i) for i in range(1, 6)]:
            area_level_location_mapping_file = os.path.join(data_directory, 'LocationMapping_{}.csv'.format(area_level_key))

            if os.path.isfile(area_level_location_mapping_file):

                area_level_location_mappings[area_level_key] = [
                    area_loc_dict for area_loc_dict in read_csv(
                        area_level_location_mapping_file,
                        csv_meta=common_utils._LOCATION_AREA_LEVEL_RECORD_META

                )
                ]


            else:
                area_level_location_mappings[area_level_key] = None
        return area_level_location_mappings

    @oasis_log()
    def _read_vulnerability_mappings(self, data_directory):
        return dict(
            (
                key,
                [
                    occ_vul_dict for occ_vul_dict in read_csv(
                        os.path.join(data_directory, '{}_OCCUPANCY_SCHEME.csv'.format(key.replace(' ', '_'))),
                        csv_meta=common_utils._OCC_SCHEME_VULNERABILITY_RECORD_META[key]
                    )
                ]
            ) for key in ["OED","ATC", "CRS", "IFM", "RMS IND", "SIC"]
        )

    @oasis_log()
    def _read_construction_classes(self, data_directory):
        return dict(
            (
                key,
                [
                    con_class_dict for con_class_dict in read_csv(
                        os.path.join(data_directory, '{}_CONSTRUCTION_CLASS.csv'.format(key.replace(' ', '_'))),
                        csv_meta=common_utils._CONSTRUCTION_CLASS_RECORD_META
                    )
                ]
            ) for key in ["OED","ATC", "CRS", "RMS"]
        )

